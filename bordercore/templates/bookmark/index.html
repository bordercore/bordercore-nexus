{% extends "base.html" %}

{% block title %} Bookmarks {% endblock %}

{% block content %}

    <div id="vue-app" class="row g-0 h-100 mx-2">

        <!-- Tags drawer overlay (for mobile) -->
        <div
            v-if="drawerOpen"
            class="bookmark-tags-drawer-overlay"
            @click="toggleDrawer"
        ></div>

        <!-- Tags section - hidden on small screens, shown in drawer -->
        <div class="col-lg-3 d-flex flex-column bookmark-tags-sidebar" :class="{'drawer-open': drawerOpen}">
            <pinned-tags
                ref="pinnedTags"
                add-tag-url="{% url "bookmark:add_tag" %}"
                remove-tag-url="{% url "bookmark:remove_tag" %}"
                sort-tags-url="{% url "bookmark:sort_pinned_tags" %}"
                @get-page="getPage(1)"
                @search-tag="searchTag"
            >
        </div>

        <div class="col-lg-9">

            <div>

                <div id="bookmark-search-form" class="d-flex flex-column me-2 p-3">
                    <div v-cloak>
                        <div class="d-flex">
                            <!-- Tags/Filters button for mobile -->
                            <button
                                type="button"
                                class="btn btn-primary bookmark-tags-drawer-toggle d-lg-none me-2"
                                @click="toggleDrawer"
                                aria-label="Toggle Tags"
                            >
                                <font-awesome-icon icon="tags" class="me-2"></font-awesome-icon>
                                Tags
                            </button>
                            <form class="form-inline" role="form" method="get" @submit.prevent>
                            {% csrf_token %}
                                <input :value="pinnedTags && bookmarkStore.selectedTagName" type="hidden" name="tag" />
                                <div class="position-relative" v-cloak>
                                    <div ref="search">
                                        <select-value
                                            id="bookmarkSearch"
                                            ref="selectValue"
                                            search-url="{% url 'bookmark:get_tags_used_by_bookmarks' %}?query="
                                            place-holder="Search term or tag"
                                            :search-icon="true"
                                            @select="selectTag"
                                            @search="handleSearch"
                                        >
                                        </select-value>
                                    </div>
                                </div>
                            </form>
                            <div class="btn-group ms-3" role="group" aria-label="List View">
                                <button type="button" class="btn btn-primary" :class="{'active': viewType === 'normal' }" @click="switchViewType('normal')">Normal</button>
                                <button type="button" class="btn btn-primary" :class="{'active': viewType === 'compact' }" @click="switchViewType('compact')">Compact</button>
                            </div>
                            <drop-down-menu class="my-auto">
                                <template #dropdown v-cloak>
                                    <li>
                                        <a v-if="tagIsSelected" class="dropdown-item" href="#" @click.prevent="onTogglePinStatus">
                                            <font-awesome-icon icon="thumbtack" class="text-primary me-3"></font-awesome-icon>
                                            [[ getPinnedMenuItem() ]]
                                        </a>
                                    </li>
                                    <li>
                                        <a class="dropdown-item" href="{% url 'bookmark:create' %}">
                                            <span v-cloak>
                                                <font-awesome-icon icon="plus" class="text-primary me-3"></font-awesome-icon>
                                                New Bookmark
                                            </span>
                                        </a>
                                    </li>
                                </template>
                            </drop-down-menu>
                        </div>
                    </div>
                    <div v-cloak>
                        <div class="d-flex mt-1 ms-3">

                            <div v-if="tagIsSelected" id="bookmark-search-filter" class="tag d-flex align-items-center">
                                <div>Tag: <strong>[[ bookmarkStore.selectedTagName ]]</strong></div>
                                <div>
                                    <a class="ms-1" href="#" @click.prevent="removeFilter">
                                        <font-awesome-icon icon="times" class="text-primary" />
                                    </a>
                                </div>
                            </div>

                            <div v-if="searchTerm" id="bookmark-search-filter" class="tag label label-info d-flex align-items-center">
                                <div>Term: <span class="text-white">[[ searchTerm ]]</span></div>
                                <div>
                                    <a class="ms-1" href="#" @click.prevent="removeFilter">
                                        <font-awesome-icon icon="times" class="text-primary" />
                                    </a>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>

            </div>

            <div class="card-grid h-100 ps-0 mt-2">
                <div id="bookmark-list-container" class="interior-borders scrollable-panel-scrollbar-hover vh-100">
                    <ul class="list-group list-group-flush interior-borders h-100">
                        <vue-draggable
                            v-model="bookmarkList"
                            :distance="3"
                            ghost-class="slicklist-helper"
                            @end="handleBookmarkSort"
                            handle=".drag-handle"
                            :filter="bookmarkStore.selectedTagName === 'Untagged' ? '.no-drag' : undefined"
                            tag="div"
                        >
                            <div
                                v-for="(element, index) in bookmarkList"
                                :key="element.uuid"
                                :class="['hover-reveal-target', { 'no-drag': bookmarkStore.selectedTagName === 'Untagged' }]"
                            >
                                <div class="slicklist-list-item-inner">
                                    <li
                                        :data-uuid="element.uuid"
                                        :key="element.uuid"
                                        class="dropdown-height hover-target bookmark-list list-group-item w-100"
                                        v-cloak
                                        @click="onClickBookmark(element.uuid)"
                                        @dragstart="onDragStartBookmark($event, element)"
                                        @mouseenter="onMouseEnterLeave"
                                        @mouseleave="onMouseEnterLeave"
                                    >
                                        <div class="d-flex">
                                            <div class="drag-handle d-flex flex-grow-0 flex-shrink-0 align-items-center">
                                                <div class="hover-reveal-object d-none">
                                                    <font-awesome-icon icon="bars"></font-awesome-icon>
                                                </div>
                                            </div>
                                            <div class="date flex-grow-0 flex-shrink-0 me-2 align-top">
                                                [[ element.created ]]
                                            </div>
                                            <div v-if="viewType !== 'compact'" class="thumbnail handle p-2">
                                                <img width="120" height="67" :src="element.thumbnail_url" />
                                            </div>
                                            <div class="mx-2" v-html="element.favicon_url">
                                            </div>
                                            <div class="position-relative flex-grow-1">
                                                <a class="me-2" :href="element.url" :id="element.linkId" target="_blank">[[ unescapeHtml(element.name) ]]</a>
                                                <a v-for="tag in filteredTags(element)" class="tag ms-2 d-inline-block" @click.prevent="searchTag(tag)" href="#">[[ tag ]]</a>
                                                <div class="yt-hover-target position-absolute text-secondary d-none"
                                                    v-if="element.url.startsWith('https://www.youtube.com/watch') && viewType === 'normal'">
                                                    [[ element.video_duration ]]
                                                </div>
                                                <div v-if="element.note != null && element.note != ''" class="table-note" v-html="getNote(element.note)">
                                                </div>
                                            </div>
                                            <div>
                                                <drop-down-menu :show-on-hover="true" class="me-4">
                                                    <template #dropdown>
                                                        <li>
                                                            <a class="dropdown-item" href="#" @click.prevent="onClickEditBookmark(element.uuid)">
                                                                <font-awesome-icon icon="pencil-alt" class="text-primary me-3"></font-awesome-icon>Edit
                                                            </a>
                                                        </li>
                                                        <li>
                                                            <a class="dropdown-item" href="#" @click.prevent="onClickDeleteBookmark(element.uuid)">
                                                                <font-awesome-icon icon="trash-alt" class="text-primary me-3"></font-awesome-icon>Delete
                                                            </a>
                                                        </li>
                                                    </template>
                                                </drop-down-menu>
                                            </div>
                                        </div>
                                    </li>
                                </div>
                            </div>
                        </vue-draggable>
                    </ul>
                    <div v-if="bookmarkList.length === 0" v-cloak>
                        <div class="text-center pt-3">
                            No bookmarks found.
                        </div>
                    </div>
                </div>

                <div class="d-flex justify-content-center">

                    <div class="ms-3 mt-3" v-cloak>
                        <div class="row" v-if="pagination.num_pages > 1">
                            <nav aria-label="Page navigation">
                                <ul class="pagination">
                                    <li v-if="pagination.previous_page_number" class="page-item"><a class="page-link" @click.prevent="getPage(pagination.previous_page_number)" href="">Previous</a></li>
                                    <li v-else class="disabled page-item"><a class="page-link" href="">Previous</a></li>

                                    <template v-if="pagination.page_number - pagination.paginate_by > 1 && pagination.num_pages > 4">
                                        <li class="page-item"><a class="page-link" @click.prevent="getPage(1)" href="">1</a></li>
                                        <li v-if="pagination.page_number != pagination.paginate_by + 2" class="disabled page-item"><a class="page-link" href="">...</a></li>
                                    </template>

                                    <template v-for="page in pagination.range">

                                        <template v-if="pagination.page_number == page">
                                            <li class="disabled page-item">
                                                <a class="page-link" href="">[[ page ]]</a>
                                            </li>
                                        </template>
                                        <template v-else>
                                            <li class="page-item">
                                                <a class="page-link" @click.prevent="getPage(page)" href="">[[ page ]]</a>
                                            </li>
                                        </template>

                                    </template>

                                    <template v-if="pagination.num_pages - pagination.page_number > pagination.paginate_by && pagination.num_pages > 4">
                                        <li v-if="pagination.num_pages - pagination.page_number != pagination.paginate_by + 1"  class="disabled page-item"><a class="page-link" href="">...</a></li>
                                        <li class="page-item"><a class="page-link" @click.prevent="getPage(pagination.num_pages)" href="">[[ pagination.num_pages ]]</a></li>
                                    </template>

                                    <li v-if="pagination.next_page_number" class="page-item"><a class="page-link" @click.prevent="getPage(pagination.next_page_number)" href="">Next</a></li>
                                    <li v-else class="disabled page-item"><a class="page-link" href="">Next</a></li>
                                </ul>
                            </nav>
                        </div>
                    </div>

                </div>

            </div>

        </div>

    </div>

{% endblock %}

{% block javascript %}

    {{ block.super }}

    {{ tag|json_script:"initialTag" }}
    {{ pinned_tags|json_script:"pinnedTags"|default:"" }}

    <script type="text/javascript">

        const app = createApp({
            name: "BookmarkList",
            components: {
                DropDownMenu,
                FontAwesomeIcon,
                PinnedTags,
                SelectValue,
                "vue-draggable": VueDraggable,
            },
            delimiters: ["[[", "]]"],
            setup() {
                const bookmarkList = ref([]);
                const bookmarkStore = useBookmarkStore();
                let intervalId = null;
                const pagination = ref({});
                const searchTerm = ref();
                const selectedBookmarkUuid = ref();
                const viewType = ref("{{ request.session.bookmark_view_type|default:'normal' }}");
                const drawerOpen = ref(false);

                const pinnedTags = ref(null);
                const selectValue = ref(null);

                onMounted(() => {

                    document.addEventListener("focusin", (event) => {
                        // De-select any selected bookmark whenever an element on the
                        //  page gets focus to prevent unwarranted hotkey actions.
                        selectedBookmarkUuid.value = null;
                        document.querySelectorAll("li.bookmark-list").forEach(row => {
                            row.classList.remove("selected");
                        });
                    });

                    pinnedTags.value.setTags(
                        JSON.parse(document.getElementById("pinnedTags").textContent),
                        {{ untagged_count }}
                    );

                    const tag = JSON.parse(document.getElementById("initialTag").textContent);
                    if (tag) {
                        getBookmarkList({ searchTag:tag });
                    } else {
                        getBookmarkList({ pageNumber:1 });
                    }

                    hotkeys("alt+down,alt+up,d,o,escape", function (event, handler) {
                        let index = null;
                        switch (handler.key) {
                            case "alt+down":
                                if (!selectedBookmarkUuid.value) {
                                    selectedBookmarkUuid.value = bookmarkList.value[0].uuid;
                                } else {
                                    selectedBookmarkUuid.value = getNextBookmark();
                                }
                                selectBookmark();
                                break;
                            case "alt+up":
                                if (!selectedBookmarkUuid.value) {
                                    selectedBookmarkUuid.value = bookmarkList.value[bokmarkList.value.length - 1].uuid;
                                } else {
                                    selectedBookmarkUuid.value = getPreviousBookmark();
                                }
                                selectBookmark();
                                break;
                            case "d":
                                if (selectedBookmarkUuid.value) {
                                    index = bookmarkList.value.findIndex((e) => e.uuid === selectedBookmarkUuid.value);
                                    const nextBookmark = getNextBookmark();
                                    onClickDeleteBookmark(bookmarkList.value[index].uuid);
                                    selectedBookmarkUuid.value = nextBookmark;
                                    selectBookmark();
                                }
                                break;
                            case "o":
                                if (selectedBookmarkUuid.value) {
                                    index = bookmarkList.value.findIndex((e) => e.uuid === selectedBookmarkUuid.value);
                                    window.open(bookmarkList.value[index].url, "_blank");
                                    onClickDeleteBookmark(bookmarkList.value[index].uuid);
                                    selectedBookmarkUuid.value = null;
                                }
                                break;
                            case "escape":
                                selectedBookmarkUuid.value = null;
                                document.querySelectorAll("li.bookmark-list").forEach(row => {
                                    row.classList.remove("selected");
                                });
                                break;
                        }
                    });
                });

                function filteredTags(bookmark) {
                    return bookmark.tags.filter((x) => x !== bookmarkStore.selectedTagName);
                }

                function getBookmarkList({ pageNumber = 1, searchTermParam = null, searchTag = null } = {}) {
                    if (searchTag !== null) {
                        url = "{% url 'bookmark:get_bookmarks_by_tag' 666 %}".replace(/666/, searchTag);
                        searchTermParam = null;
                    } else if (searchTermParam !== null) {
                        url = "{% url 'bookmark:get_bookmarks_by_keyword' 666 %}".replace(/666/, searchTermParam);
                    } else {
                        url = "{% url 'bookmark:get_bookmarks_by_page' 666 %}".replace(/666/, pageNumber);
                    }

                    axios.get(url)
                         .then(function (response) {
                             // For bookmarks which share the same date, only show the
                             //  date for the first one, to reduce UI clutter.
                             let bookmarks = []
                             let lastDate = null;
                             for (bookmark of response.data.bookmarks) {
                                 if (bookmark.created == lastDate) {
                                     lastDate = bookmark.created;
                                     bookmark.created = null;
                                 } else {
                                     lastDate = bookmark.created;
                                 }
                                 bookmarks.push(bookmark);
                             }

                             searchTerm.value = searchTermParam;
                             bookmarkList.value = bookmarks;
                             pagination.value = response.data.pagination;

                            if (searchTag !== null) {
                                // Only update the tagFilter here, *after* we have a new set of
                                // updated bookmarks that's appropriate for this tagFilter
                                bookmarkStore.selectedTagName = searchTag;
                            } else if (searchTermParam !== null) {
                                bookmarkStore.selectedTagName = null;
                            } else {
                                bookmarkStore.selectedTagName = "Untagged";

                                if (Object.entries(pagination.value).length === 0 || pagination.value.page_number === 1) {
                                    // First clear any existing timeouts, if necessary
                                    clearTimeout(intervalId);
                                    intervalId = window.setTimeout(getBookmarkList, 60000, { pageNumber: pageNumber });
                                }
                            }
                         })
                         .catch(function (error) {
                             console.log("Error getting new bookmarks list: " + error);
                         });
                };

                function getNextBookmark() {
                    const index = bookmarkList.value.findIndex((e) => e.uuid === selectedBookmarkUuid.value);
                    if (index < bookmarkList.value.length - 1) {
                        return bookmarkList.value[index + 1].uuid;
                    }
                };

                function getNote(note) {
                    return markdown.render(note);
                };

                function getPage(pageNumber) {
                    clearTimeout(intervalId);
                    getBookmarkList({ pageNumber: pageNumber });
                };

                function getPinnedMenuItem() {
                    return !pinnedTags.value.tags.find(
                        element => element.name == bookmarkStore.selectedTagName
                    ) ? "Pin" : "Unpin";
                };

                function getPreviousBookmark() {
                    const index = bookmarkList.value.findIndex((e) => e.uuid === selectedBookmarkUuid.value);
                    if (index > 0) {
                        return bookmarkList.value[index - 1].uuid;
                    }
                };

                function handleSearch(query) {
                    getBookmarkList({ searchTermParam: query });
                };

                function onClickBookmark(uuid) {
                    selectedBookmarkUuid.value = uuid;
                    selectBookmark();
                };

                function onClickDeleteBookmark(uuid) {
                    axios.delete("{% url 'bookmark-detail' '00000000-0000-0000-0000-000000000000' %}".replace('00000000-0000-0000-0000-000000000000', uuid))
                        .then((response) => {
                            EventBus.$emit(
                                "toast",
                                {
                                    "body": "Bookmark deleted",
                                },
                            );

                            if (bookmarkStore.selectedTagName) {
                                if (bookmarkStore.selectedTagName === "Untagged") {
                                    getBookmarkList({ pageNumber: pagination.value.page_number });
                                } else
                                    getBookmarkList({ searchTag: bookmarkStore.selectedTagName });
                            } else {
                                getBookmarkList({ pageNumber: pagination.value.page_number });
                            }
                        })
                        .catch((error) => {
                            if (error.response && (error.response.status === 404 || error.response.status === 500)) {
                                const errorMessage = error.response.data && error.response.data.message 
                                    ? error.response.data.message 
                                    : "An error occurred while deleting the bookmark";
                                EventBus.$emit(
                                    "toast",
                                    {
                                        "body": errorMessage,
                                        "variant": "danger",
                                    },
                                );
                            }
                        })
                };

                function onClickEditBookmark(uuid) {
                    window.location = "{% url 'bookmark:update' '00000000-0000-0000-0000-000000000000' %}".replace(/00000000-0000-0000-0000-000000000000/, uuid);
                };

                function onDragStartBookmark(evt, bookmark) {
                    evt.dataTransfer.dropEffect = "move";
                    evt.dataTransfer.effectAllowed = "move";
                    evt.dataTransfer.setData("application/x-moz-node", bookmark.uuid);
                };

                function onMouseEnterLeave(evt) {
                    const YTTarget = evt.currentTarget.querySelector(".yt-hover-target");
                    if (!YTTarget) {
                        return;
                    }
                    if (evt.type === "mouseenter") {
                        YTTarget.classList.remove("d-none");
                    } else {
                        YTTarget.classList.add("d-none");
                    }
                };

                function handleBookmarkSort(event) {
                    if (event.oldIndex === event.newIndex) {
                        return;
                    }
                    // Ignore this event if we're not filtering on a tag.
                    if (bookmarkStore.selectedTagName === "Untagged") {
                        return false;
                    }
                    // v-model has already updated the array, so the dragged item is now at newIndex
                    const bookmarkUuid = bookmarkList.value[event.newIndex].uuid;

                    // The backend expects the ordering to begin with 1, not 0, so add 1.
                    const newPosition = event.newIndex + 1;

                    doPost(
                        "{% url "bookmark:sort" %}",
                        {
                            "tag": bookmarkStore.selectedTagName,
                            "bookmark_uuid": bookmarkUuid,
                            "position": newPosition
                        },
                        (response) => {},
                        "",
                        "Sort error"
                    );

                };

                function onTogglePinStatus() {
                    let formAction = null;
                    formAction = getPinnedMenuItem() === "Pin" ?
                                 "{% url 'tag:pin' %}" :
                                 "{% url 'tag:unpin' %}";
                    const form = document.querySelector("#bookmark-search-form form");
                    form.method = "post";
                    form.action = formAction;
                    form.submit();
                };

                function removeFilter() {
                    searchTerm.value = null;
                    searchTag("Untagged");
                };

                function searchTag(tagName) {
                    // Clear any timeouts to prevent the list from refreshing
                    clearTimeout(intervalId);

                    if (tagName == "Untagged") {
                        getBookmarkList({ pageNumber:1 });
                    } else {
                        getBookmarkList({ searchTag:tagName });
                    };
                };

                function selectBookmark() {
                    document.querySelectorAll("li.bookmark-list").forEach(row => {
                        row.classList.remove("selected");
                    });

                    document.querySelector("li.bookmark-list[data-uuid='" + selectedBookmarkUuid.value + "']").classList.add("selected");
                };

                function selectTag(tagInfo) {
                    nextTick(() => {
                        selectValue.value.clearOptions();
                    });
                    searchTag(tagInfo.label);
                };

                function switchViewType(type) {
                    viewType.value = type;
                    doPost(
                        "{% url "accounts:store_in_session" %}",
                        {
                            "bookmark_view_type": type
                        },
                        (response) => {},
                    );
                };

                function toggleDrawer() {
                    drawerOpen.value = !drawerOpen.value;
                };

                function unescapeHtml(html) {
                    // Source: https://stackoverflow.com/a/46851765/378256
                    const el = document.createElement("div");
                    return html.replace(/\&[#0-9a-z]+;/gi, function(enc) {
                        el.innerHTML = enc;
                        return el.innerText;
                    });
                };

                const tagIsSelected = computed(() => {
                    return pinnedTags.value && bookmarkStore.selectedTagName !== null && bookmarkStore.selectedTagName !== "Untagged";
                });

                // Close drawer when a tag is selected on mobile
                watch(() => bookmarkStore.selectedTagName, () => {
                    if (drawerOpen.value && window.innerWidth < 992) {
                        drawerOpen.value = false;
                    }
                });

                return {
                    bookmarkList,
                    bookmarkStore,
                    drawerOpen,
                    filteredTags,
                    getBookmarkList,
                    getPage,
                    handleBookmarkSort,
                    handleSearch,
                    onClickBookmark,
                    onClickDeleteBookmark,
                    onClickEditBookmark,
                    pagination,
                    getNextBookmark,
                    getNote,
                    getPinnedMenuItem,
                    getPreviousBookmark,
                    onDragStartBookmark,
                    onMouseEnterLeave,
                    onTogglePinStatus,
                    pinnedTags,
                    removeFilter,
                    searchTag,
                    searchTerm,
                    selectBookmark,
                    selectedBookmarkUuid,
                    selectTag,
                    selectValue,
                    switchViewType,
                    tagIsSelected,
                    toggleDrawer,
                    unescapeHtml,
                    viewType,
                }
            },
        });
        app.use(createPinia());
        app.mount("#vue-app");

    </script>

{% endblock %}

{% block help %}

    <div class="d-none" id="help-text">
# Keyboard Shortcuts
- **Alt-Up**, **Alt-Down** *-* Select a bookmark
- **D** *-* Delete the selected bookmark
- **O** *-*  Open and delete the selected bookmark
- **Escape** *-* Unselect the selected bookmark
    </div>

{% endblock %}
